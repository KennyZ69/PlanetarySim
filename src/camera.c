/* camera.c */

#include "in/camera.h"
#include <SDL2/SDL_events.h>
#include <SDL2/SDL_keycode.h>
#include <SDL2/SDL_mouse.h>

void cam_init(Camera *cam) {
	cam->vertical = 0.75f; // slightly above the horizon
	cam->horizontal = 3.14f / 4.0f; // 45 degrees in radians
	cam->dist = 40.0f;
	cam->zoom = 0.75f;
	cam->rot = 0.005f;
	cam->pan = 0.10f;
	cam->rotating = false;
	cam->panning = false;
	cam->last_x = 0;
	cam->last_y = 0;
	cam->target = (Vec3D){0.0f, 0.0f, 0.0f};
}

void apply_cam_view(Camera *cam) {
	float camX = cam->target.x + cam->dist * cosf(cam->vertical) * sinf(cam->horizontal);
	float camY = cam->target.y + cam->dist * sinf(cam->vertical);
	float camZ = cam->target.z + cam->dist * cosf(cam->vertical) * cosf(cam->horizontal);
	gluLookAt(camX, camY, camZ, cam->target.x, cam->target.y, cam->target.z, 0.0f, 1.0f, 0.0f);
}

void handle_cam_event(Camera *cam, SDL_Event *ev) {
	switch (ev->type) {
		case SDL_KEYDOWN:
			switch (ev->key.keysym.sym) {
				case SDLK_w:
					cam->target.y += cam->pan * cam->dist;
					break;
				case SDLK_s:
					cam->target.y -= cam->pan * cam->dist;
					break;
				case SDLK_a:
				case SDLK_LEFT:
					cam->target.x -= cam->pan * cam->dist;
					break;
				case SDLK_d:
				case SDLK_RIGHT:
					cam->target.x += cam->pan * cam->dist;
					break;
				case SDLK_q:
				case SDLK_DOWN:
					cam->target.z += cam->pan * cam->dist;
					break;
				case SDLK_e:
				case SDLK_UP:
					cam->target.z -= cam->pan * cam->dist;
					break;
				default:
					break;
			}
			break;
		case SDL_MOUSEBUTTONDOWN:
			if (ev->button.button == SDL_BUTTON_LEFT) {
				cam->panning = true;
				cam->last_x = ev->button.x;
				cam->last_y = ev->button.y;
			} else if (ev->button.button == SDL_BUTTON_RIGHT) {
				cam->rotating = true;
				cam->last_x = ev->button.x;
				cam->last_y = ev->button.y;
			}
			break;
		case SDL_MOUSEBUTTONUP:
			if (ev->button.button == SDL_BUTTON_LEFT) {
				cam->panning = false;
			} else if (ev->button.button == SDL_BUTTON_RIGHT) {
				cam->rotating = false;
			}
			break;
		case SDL_MOUSEMOTION:
			int dx = ev->motion.x - cam->last_x;
			int dy = ev->motion.y - cam->last_y;
			cam->last_x = ev->motion.x;
			cam->last_y = ev->motion.y;
			if (cam->rotating) {
				cam->horizontal -= dx * cam->rot;
				cam->vertical += dy * cam->rot;
				if (cam->vertical > 1.5f) cam->vertical = 1.5f;
				if (cam->vertical < -1.5f) cam->vertical = -1.5f;
			} else if (cam->panning) {

				// INFO: honestly Im not entirely sure why this works correctly
				// was generated by *copilot*

				// pan relative to camera orientation
				Vec3D right = {
					.x = cosf(cam->horizontal),
					.y = 0,
					.z = -sinf(cam->horizontal)
				};
				Vec3D up = {0, 1, 0};
				cam->target.x -= (right.x * dx + up.x * dy) * cam->pan;
				cam->target.y += (right.y * dx + up.y * dy) * cam->pan;
				cam->target.z -= (right.z * dx + up.z * dy) * cam->pan;

				// simple pan solution without considering camera orientation
				// float pan = cam->dist * cam->pan;
				// cam->target.x -= dx * pan;
				// cam->target.z += dy * pan;
			}
			break;
		case SDL_MOUSEWHEEL:
			if (ev->wheel.y > 0) {
				cam->dist -= cam->zoom;
				if (cam->dist < 1.0f) cam->dist = 1.0f;
			} else if (ev->wheel.y < 0) {
				cam->dist += cam->zoom;
			}
			break;

		default:
			break;
	}
}
